#include "filehelper.h"

#include <iostream>
#include <fstream>
#include <vector>
#include <map>

using namespace std;

//given address of airport file, read into airport structure
//return map of airport id to airport
map<string, airport> make_airports(string file_name)
{
	ifstream airport_file;
	airport_file.open(file_name);
	map<string, airport> airports;

	while (airport_file.good())
	{

		airport airport;
		string temp;
		getline(airport_file, airport.ID_, ',');
		getline(airport_file, airport.name_, ',');
		getline(airport_file, temp, ',');
		getline(airport_file, temp, ',');
		getline(airport_file, temp, ',');
		getline(airport_file, temp, ',');
		getline(airport_file, airport.latitude_, ',');
		getline(airport_file, airport.longitude_, ',');
		getline(airport_file, temp, '\n');

		try
		{
			stof(airport.longitude_);
			stof(airport.latitude_);
			airports[airport.ID_] = airport;
		}
		catch (...)
		{
			//Silently fail to insert airports with bad data
		}
	}
	airport_file.close();

	return airports;
}

//given routes file, read into dictionary
//return map of source to vec of all destinations
map<string, vector<string>> make_routes(string file_name)
{
	ifstream route_file;
	route_file.open(file_name);
	map<string, vector<string>> routes;

	while (route_file.good())
	{
		string temp;
		string source_ID;
		string dest_ID;

		getline(route_file, temp, ',');
		getline(route_file, temp, ',');
		getline(route_file, temp, ',');
		getline(route_file, source_ID, ',');
		getline(route_file, temp, ',');
		getline(route_file, dest_ID, ',');
		getline(route_file, temp, '\n');

		//check if source already exists in dict
		//if so, add to vect
		if (routes.find(source_ID) == routes.end())
		{
			routes[source_ID] = vector<string>{dest_ID};
		}
		else
		{
			routes[source_ID].push_back(dest_ID);
		}
	}
	route_file.close();

	return routes;
}

//given map of airport id to airport structure and map of airport id to destination airport IDs
//return a weighted, directed graph of all airports and their connecting routes
Graph make_graph(map<string, airport> airports, map<string, vector<string>> routes)
{
	Graph graph = Graph(true, true);

	//add all vertices
	for (auto &keyVal : airports)
	{
		graph.insertVertex(keyVal.first);
	}

	//add routes
	for (auto &keyVal : routes)
	{
		string source = keyVal.first;
		//only add routes when we have a vertex for both source and dest
		if (graph.vertexExists(source) && airports.find(source) != airports.end())
		{
			airport source_airport = airports[source];
			for (auto &dest : keyVal.second)
			{
				if (airports.find(dest) != airports.end() && airports.find(source) != airports.find(dest))
				{ 
					//add directed, weighted
					airport dest_air = airports[dest];
					graph.insertEdge(source, dest);
					graph.setEdgeWeight(source, dest, source_airport.find_distance(airports[dest]));
					graph.setEdgeLabel(source, dest, source_airport.name_ + "To" + dest_air.name_);
				}
			}
		}
	}

	return graph;
}


//given airports and dijkstra of airport
//build interesting statistics file
void make_statistics_file(dijkstra d, landmark l, map<string, airport> airports, string source, string file_name, vector<string> landmarks, vector<string> destinations)
{
	string source_name = airports[source].name_;
    //Create a ifstream object to redirct the output
    ofstream stats_file;
    stats_file.open(file_name);

    //file dijkstra stats
    stats_file << "##################################################################################" << endl;
    stats_file << "Autogenerated Statistics for Airport: " << airports[source].name_ << endl;
    stats_file << "##################################################################################" << endl << endl;
    stats_file << "Basic Statistics" << endl;
    stats_file << "Number of connected airports: " << d.numofairport << endl;
    stats_file << "Closest airport: " << airports[d.getMin()].name_ << endl;
    stats_file << "\tDistance: " << d.distance[d.getMin()] << " miles." << endl;
    stats_file << "Furthest airport: " << airports[d.getMax()].name_ << endl;
    stats_file << "\tDistance: " << d.distance[d.getMax()] << " miles." << endl;
    stats_file << "\tPath: " << d.getpaths(source, d.getMax()) << endl << endl;

    stats_file << "Landmark Statistics: " << endl;
    for (int i = 0; i < (int) landmarks.size(); i++) {
    	string dest_name = airports[destinations[i]].name_;
    	string land_name = airports[landmarks[i]].name_;
    	stats_file << "Distance from " <<  source_name << " to " << dest_name << " through " << land_name << " is " << l.find_distance(destinations[i], landmarks[i]) << " miles." << endl;
    }

    //file stats for every connected airport
    stats_file << endl;
    stats_file << "Shortest path to each connected airport: " << endl;
	for (auto it = d.actualdistance.begin(); it != d.actualdistance.end(); it++)
	{
		stats_file << "Distance from " << airports[source].name_  << " to " << airports[(*it).first].name_ << " is " << (*it).second << " miles." << endl;
	}
	
	stats_file.close();
}